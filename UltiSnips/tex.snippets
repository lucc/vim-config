# first include the lengthy templates:
extends tex_templates

global !p
def find_babel_languages():
    '''Return a list of babel languges for the current file.'''
    for line in vim.current.buffer:
        if line.startswith(r'\usepackage['):
            match = re.match(r'^\\usepackage\[(.*)\]{babel}$', line)
            if match:
                return match.group(1).split(',')
    return []
def map_lang(lang):
  if lang in ['de', 'german', 'ngerman']:
      return 'gernam'
  elif lang in ['en', 'english']:
      return 'english'
  else:
      return 'unknown'
def get_spellangs():
    return vim.current.buffer.options['spelllang'].split(',')
endglobal

# the strange python evals are only needed as long as completion of bib keys
# does not work
snippet "ci( (\S+))?" "a full featured \cite[]{} command" r
\cite[`!p
try: lang = find_babel_languages()[-1]
except IndexError: lang = get_spellangs[1]
lang = map_lang(lang)
if lang == 'german':
    snip.rv = 'S.~'
elif lang == 'english':
    snip.rv ='p.~'
else:
    snip.rv = 'S.~'`${1:pages}]{${2:`!p
snip.rv = match.group(2) if match.group(1) is not None else "bibkey"`}}$0
endsnippet

snippet "cite( (\S+))" "a simple \cite{} command" r
\cite{${1:`!p
snip.rv = match.group(2) if match.group(1) is not None else "bibkey"`}}$0
endsnippet

snippet "nci( (\S))" "a \nocite{} command" r
\nocite{${1:`!p
snip.rv = match.group(2) if match.group(1) is not None else "bibkey"`}}$0
endsnippet

snippet nc "newcommand"
\newcommand\\${1:cmd}[$2]{$3}$0
endsnippet

snippet "b(egin)?( (\S+))?" "begin{} / end{}" br
\begin{${1:`!p
snip.rv = match.group(3) if match.group(2) is not None else "something"`}}
	${2:${VISUAL}}
\end{$1}$0
endsnippet

snippet test "Description" b
`!p snip.rv=1`
`!p snip.rv=2`
endsnippet
